
# ОРГАНИЗАЦИЯ КОДА В GO ПРОЕКТАХ

1. Структура проекта Go и система модулей

- Создание и управление модулями
  - 1️⃣ go mod init github.com/username/my-project
  
    Эта команда создаёт новый модуль Go в вашей папке проекта. Модуль — это набор пакетов Go, который можно управлять 
    как единым проектом.

    Строка module github.com/username/my-project задаёт имя вашего модуля. Обычно используют URL 
    репозитория (GitHub, GitLab), чтобы позже можно было импортировать этот модуль в другие проекты.
    После этого Go начинает отслеживать зависимости и версии пакетов.
  
  - 2️⃣ go get github.com/some/dependency

    Эта команда устанавливает и добавляет внешние зависимости (пакеты) в ваш проект. 
    Go скачивает пакет из репозитория (например, GitHub). Добавляет запись о версии пакета в go.mod. Создаёт файл 
    go.sum (если его нет) или обновляет его. В go.sum хранится контрольная сумма пакета для безопасности: 
    Go проверяет, что пакет не изменился.

Go-проект обычно организован следующим образом:

my-project
├── cmd
│   └── app
│       └── main.go
├── pkg
│   ├── database
│   │   ├── database.go
│   │   └── database_test.go
│   └── utils
│       ├── helpers.go
│       └── helpers_test.go
├── internal
│   └── api
│       └── handlers.go
├── go.mod
└── go.sum


Каталог	    Назначение
cmd	        Точки входа приложений (main-функции)
pkg	        Переиспользуемые пакеты (открытые для внешних проектов)
internal	Внутренние пакеты проекта (доступны только внутри проекта)

2. Пакеты и импорт

**Пакет объявляется первой строкой файла:**

```go
package utils


import “strings”

// MakeUpperCase преобразует строку в верхний регистр
func MakeUpperCase(s string) string {
return strings.ToUpper(s)
}
```

**Импортировать пакеты можно несколькими способами:**

```go
// Стандартный импорт
import "fmt"


// Импорт с алиасом
import alias “github.com/user/package”

// Точечный импорт (не рекомендуется без особых причин)
import . “github.com/user/package”

```

**Видимость идентификаторов**
В Go идентификаторы (переменные, функции, типы) экспортируются, если начинаются с заглавной буквы, и остаются 
приватными, если начинаются со строчной:

3. Организация тестов в Go
Тесты размещаются рядом с кодом, который они проверяют, в файлах с суффиксом _test.go:

```go
package utils

import “testing”

func TestMakeUpperCase(t *testing.T) {
input := “hello”
expected := “HELLO”
if result := MakeUpperCase(input); result != expected {
t.Errorf(“expected %s, got %s”, expected, result)
}
}
```
Запустить тесты можно командой: go test ./...

------------------------------------------------------------------------------------------------------------------------

# УПРАВЛЕНИЕ ЗАВИСИМОСТЯМИ И ПОДКЛЮЧЕНИЕ ВНЕШНИХ БИБЛИОТЕК

**Зависимость** — это сторонний код (библиотека, пакет, фреймворк), который твоя программа использует для выполнения 
определенных функций.

**Зачем нужны зависимости?**
- Экономия времени — не нужно "изобретать велосипед", можно использовать готовые решения
- Надежность — популярные библиотеки тщательно тестируются сообществом
- Поддержка — библиотеки обновляются, исправляются ошибки и добавляется новая функциональность

Примеры типичных зависимостей в Go-проектах:
- Фреймворки для веб-разработки (Gin, Echo)
- Библиотеки для работы с базами данных (GORM, pgx)
- Логгеры (logrus, zap)
- Утилиты для тестирования (testify)

1. Эволюция управления зависимостями в Go

До появления модулей (до Go 1.11) изначально Go использовал простой подход GOPATH:
- Все исходные коды располагались в одной директории ($GOPATH/src)
- Не было явного управления версиями — всегда использовалась последняя версия
- Это создавало проблемы: сложность работы с разными версиями библиотек, конфликты между проектами

Из-за ограничений GOPATH появились альтернативные инструменты:
- dep
- glide
- godep

С выходом Go 1.11 (2018 год) был представлен официальный механизм управления зависимостями — Go Modules.

2. Что такое модуль в Go
Модуль — это коллекция пакетов Go с общей версией, которая публикуется и используется как единое целое.

**Модуль представляет собой:**
- Один или несколько пакетов Go
- Файл go.mod, описывающий модуль и его зависимости
- Возможность указывать конкретные версии зависимостей

**Ключевые особенности модулей:**
- Не требуют размещения в GOPATH
- Позволяют явно контролировать версии зависимостей
- Обеспечивают воспроизводимость сборки (одинаковый результат на разных машинах)
- Поддерживают работу с прокси-серверами зависимостей

**Создание и инициализация модуля**
``go mod init имя_модуля`` // создание и инициализация модуля

Имя модуля обычно соответствует пути репозитория:
``go mod init github.com/username/project``
Эта команда создаст файл 
``go.mod: module github.com/username/project
  go 1.22``

**Зачем нужно управление зависимостями**
Управление зависимостями позволяет проектам стабильно использовать сторонние библиотеки, контролировать их версии 
и минимизировать риски ошибок при обновлениях или изменениях библиотек.

Представь, что твоё приложение использует несколько внешних библиотек, и одна из них обновилась, полностью изменив 
свой интерфейс. Без контроля версий твоё приложение может перестать работать после простого обновления зависимостей. 
Управление версиями позволяет избежать таких проблем.

**Семантическое версионирование**
Go использует семантическое версионирование формата MAJOR.MINOR.PATCH:

Версия	Значение	                      Пример
MAJOR	Несовместимые изменения	          Удаление или изменение функций
MINOR	Новая функциональность	          Добавление функций
PATCH	Исправления и мелкие улучшения	  Исправление багов

**Как Go управляет зависимостями**
Go использует несколько ключевых механизмов для эффективного управления зависимостями:
- Скачивание (при выполнении go get модули скачиваются в локальный кэш)
- Разрешение версий (Go автоматически выбирает наиболее подходящие версии зависимостей)
- Проверка целостности (с помощью файла go.sum)
- Минимизация зависимостей —(через команду go mod tidy)

**MVS (Minimal Version Selection)**
Go использует алгоритм MVS для выбора версий зависимостей: Выбирается минимальная версия, удовлетворяющая всем 
требованиям. Это делает сборку стабильнее и предсказуемее

**Управление версиями зависимостей**
- Установка конкретной версии ``go get github.com/gin-gonic/gin@v1.9.0``
- Обновление отдельной библиотеки: ``go get -u github.com/gin-gonic/gin``
- Обновление всех библиотек в проекте: ``go get -u ./...``
- После обновления Go автоматически изменит версии в файле go.mod.

**Удаление зависимостей**
Удалить зависимость можно, удалив её упоминания в коде и выполнив команду: ``go mod tidy``. 
Это очистит неиспользуемые зависимости.


**Работа с файлами go.mod и go.sum**
1. Файл ``go.mod`` содержит информацию о модуле, версиях зависимостей и версии Go:
```go
module github.com/user/project

go 1.22

require (
github.com/gin-gonic/gin v1.9.0
github.com/sirupsen/logrus v1.9.3
)
```
2. Файл go.sum автоматически генерируется Go и обеспечивает целостность зависимостей. Его нельзя редактировать вручную.


**Типичные ошибки и способы их решения**
1. Ошибка загрузки модуля - Проверь настройку GOPROXY: ``go env -w GOPROXY=https://proxy.golang.org,direct``
2. Конфликт версий - Используй явное указание проверенных версий: ``go get github.com/gin-gonic/gin@v1.8.1``

**Подключение внешних библиотек и структура проекта**
Пример подключения библиотеки - Создадим простой сервер с использованием библиотеки Gin:
```go
package main

import (
"github.com/gin-gonic/gin"
"net/http"
)

func main() {
router := gin.Default()

	router.GET("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"message": "pong"})
	})

	router.Run(":8080")
}
```

Установим Gin: ``go get github.com/gin-gonic/gin``
Запускаем сервер: ``go run main.go``

**Рекомендуемая структура проекта**
project/
├── cmd/
│   └── app/
│       └── main.go
├── internal/
│   ├── handlers/
│   └── services/
├── pkg/
│   └── utils/
├── go.mod
└── go.sum

cmd/app – точка входа в приложение.
internal – код, используемый внутри проекта.
pkg – публичные пакеты и утилиты.

Каталог vendor/ - используется для хранения локальных копий зависимостей проекта. Он создаётся командой: ``go mod vendor``
Эта команда скачивает и помещает используемые зависимости в директорию vendor/, что полезно для:
- Создания стабильных сборок, независимых от внешних источников (например, при ограниченном доступе к сети).
- Фиксации версий зависимостей непосредственно в проекте.
- 
Для использования зависимостей из каталога vendor/ при сборке, выполняй: ``go build -mod=vendor``
Если каталог vendor/ больше не нужен, его можно безопасно удалить вручную командой: ``rm -rf vendor``
После удаления выполни команду ``go mod tidy``, чтобы синхронизировать зависимости.

## ВЫВОДЫ
* Зависимости — это сторонние библиотеки, которые расширяют возможности твоего приложения.
* Go Modules — это официальный механизм управления зависимостями в Go, заменивший устаревший подход с GOPATH.
* Модуль в Go — это коллекция пакетов с общей версией и описанием в файле go.mod.
* Go использует семантическое версионирование для контроля изменений библиотек.
* Установка, обновление и удаление зависимостей выполняются простыми командами.
* Чёткая структура проекта помогает лучше поддерживать кодовую базу и работать с зависимостями.

------------------------------------------------------------------------------------------------------------------------

# ОСНОВЫ GIT ДЛЯ РАЗРАБОТЧИКА

1. Клонирование репозитория ``git clone https://studentgit.kata.academy/ваш_логин/kata-go.git``
2. Переход в директорию проекта ``cd kata-go``
3. Просмотр текущей ветки ``git branch``
4. Создание новой ветки и переключение на неё  ``git checkout -b task/имя-задачи``
5. Просмотр измененных файлов ``git status``
6. Добавление файлов в индекс
``git add . ``              # Добавить все изменения
``git add путь/к/файлу ``   # Добавить конкретный файл
7. Создание коммита ``git commit -m "feat: краткое описание изменений"``
8. Первая отправка новой ветки ``git push -u origin task/имя-задачи``
9. Последующие отправки (после -u можно использовать просто) ``git push``
10. Просмотр истории коммитов ``git log``
11. Компактный просмотр истории ``git log --oneline``
12. Просмотр различий между текущим состоянием и последним коммитом ``git diff``
13. Просмотр всех веток (локальных и удаленных) ``git branch -a``
14. Удаление локальной ветки ``git branch -d имя-ветки``
15. Переключение на существующую ветку ``git checkout имя-ветки``
16. Скачивание изменений без слияния ``git fetch``
17. Просмотр удаленных репозиториев ``git remote -v``


