# Ревью по модулям 1-3 

## Модуль 1: Структура Go-проектов и Go Modules
### 1. Что делает `go mod init` ?
Создает новый модуль и файл go.mod, для того чтобы управлять зависимостями 

### 2. Чем различаются директивы `require`, `replace`, `exclude` в go.mod?
require - указывает зависимость и нужную версию (Указывает, что проекту необходим этот пакет определенной версии.)
replace - подмен одной зависимости на другую
exclude - запрещает использование конкретной зависимости

### 3. Зачем нужен файл go.sum и когда он обновляется?
`go.sum `хранит хеши зависимостей и обеспечивает безопасность сборки проекта (При каждой сборке (go build, go test) 
Go проверяет, совпадают ли хеши загруженных модулей с теми, что записаны в go.sum.) 
`go.sum` обновляется:
* при добавлении новых зависимостей
* при изменении уже существующих зависимостей
* после `go mod tidy` (удаление неиспользуемых зависимостей)
* после `go get` (установка и обновление зависимостей)

### 4. Что выполняет go mod tidy и почему её ставят в CI?
Команда `go mod tidy` автоматически упорядочивает зависимости проекта, удаляя неиспользуемые модули. 
В CI (Continuous Integration) её используют для гарантии того, что файлы зависимостей актуальны, соответствуют
исходному коду и сборка воспроизводима.  

### 5. Для чего каталог internal/, и чем он отличается от обычного пакета?
Каталог internal/ в Go используется для хранения приватного кода проекта, который нельзя импортировать внешним 
по отношению к текущему модулю проектам. Обычный пакет можно импортировать откуда угодно.

### 6. Когда код помещают в cmd/, а не в корень репозитория?
Когда проект содержит один или несколько файлов бинарников

### 7. Как сделать идентификатор экспортируемым и что это даёт при импорте?
В Go все что написано с заглавной буквы автоматически становится экспортируемым. Если пакет импортирован, то 
будут доступны только экспортируемые функции.

### 8. Что такое canonical import path и как Go проверяет его корректность?
**Canonical import path** — это официальный, единственный путь, по которому пакет должен импортироваться.
В go.mod -> `module github.com/anna/project` => все пакеты внутри должны импортироваться начиная с github.com/anna/project
Проверка: 
* смотрит go.mod 
* проверяет, есть ль модуль github.com/anna/project 
* проверяет, существует ли подпакет /auth
* если путь не совпадает с module → ошибка.

### 9. Почему циклические импорты запрещены и как их избегать?
Циклические импорты создают замкнутый круг зависимостей, что усложняет компиляцию и может вызвать неявные ошибки 
исполнения. Они приводят к ситуациям, когда один модуль пытается использовать другой модуль, который не был еще
инициализирован.
Пути решения:
* Рефакторинг - вынести общую логику в третий пакет
* Инверсия зависимостей - использовать интерфейсы или абстрактные классы, чтобы модули зависели от абстракций, а не 
от друг друга
* Пересмотреть архитектуру

### 10. Как обновить конкретную зависимость до новой версии одной командой?
`go get example.com/package@latest` - до последней версии
`go get example.com/package@v1.2.3` - до конкретной версии 
и после этого `go mod tidy` чтобы удалить неиспользуемые и добавить недостающие зависимости
## Модуль 2: Типы, указатели и управление памятью
### 1. Как передаётся срез ([]T) в функцию и почему изменения могут быть видны снаружи?
Срез представляет собой структуру из 3 полей (pointer, le, cap) и при передаче передается копия этой структуры в 
функцию, но pointer внутри неё указывает на тот же массив.
Изменения **видны** снаружи т.к. в теле функции мы меняем массив, а не структуру среза. При **реаллокации** изменения 
снаружи **не будут** видны

### 2. Что произойдёт при попытке записи в nil-карту (map)?
Произойдет паника, потому что map — это ссылка на хеш-таблицу, а у nil её нет. 
nil карта НЕ равно пустая карта

### 3. Разница между new(T) и &T{} — в чём предпочтение каждой формы?
* new(T) - выделяет память для Т с нулевыми полями и возвращает *T
* &T{}  - создает экземпляр структуры, позволяет инициализировать поля Т (предпочтительнее) и возвращает *T

### 4. Что делает оператор * при разыменовании указателя?
Позволяет получить значение переменной по адресу

### 5. Как компилятор решает, «убегает» ли переменная со стека в кучу (escape-анализ)?
Если переменная живет дольше функции -> куча
Если переменная используется только внутри функции -> стек

### 6. Безопасно ли вернуть указатель на локальную переменную — почему?
Да, безопасно. Если функция возвращает указатель, то Go видит это и перенесет данную переменную в кучу

### 7. Когда выбирать int, а когда uint?
int -  целочисленный тип данных
uint - беззнаковый целочисленный тип данных (битовые операции, когда число точно не может быть отрицательным или 
нужен больший положительный диапазон)

### 8. Как правильно округлить float64 до int, избегая переполнения?
Чтобы округлить `x float64` до `int` необходимо использовать `i := matn.Round(x)`. Для того чтобы избежать переполнения
следует проверить границы с помощью проверки `if x > math.MaxInt64`

### 9. При каких условиях append увеличит cap среза?
Если произойдет переполнение (len == cap -> новый массив) 

### 10. Мини-бенчмарк: как назвать файл и функцию, чтобы go test -bench . их увидел?
1. Имя файла
   * Файл должен обязательно заканчиваться на суффикс _test.go. (пример: myfile_test.go или bench_test.go.)
   * Файл должен находиться в том же пакете (директории), что и тестируемый код.
2. Имя и сигнатура функции
   Функция должна соответствовать трем критериям:
   * Префикс: Имя должно начинаться строго с Benchmark (с большой буквы).
   * Параметр: Принимать только один аргумент типа *testing.B.
   * Экспорт: Имя после префикса должно начинаться с заглавной буквы (например, BenchmarkMyFunc, а не Benchmarkmyfunc).
## Модуль 3: Функции, defer, panic, recover
### 1. Как объявить функцию, возвращающую два значения, и зачем это удобно?
`func funcName(parametrsName parametrsType)(returnType, returnType)`
Удобно использовать для возвращения ошибок

### 2. Синтаксис variadic-функции и пример её вызова.
```go
// ...int - любое количество int
func Sum(numbs ...int) int {
	total := 0
	for _, v range numbs{
		total += v
}
	return total
}

// вызовы
a := Sum(1, 2, 3)
```
### 3. В каком порядке выполняются несколько defer-выражений?
В обратном порядке (LIFO - First In Last Out)

### 4. Отличие panic от обычного возврата ошибки — когда использовать каждое?
Panic вызывает немедленное прекращение работы программы (для багов)
Error используются для обработки предсказуемых ошибок без прекращения работы программы (для штатных проблем)

### 5. Как с помощью recover() перехватить панику и продолжить работу программы?
`recover()`можно вызвать только внутри `defer`. Он перехватывает panic и позволяет продолжить программу. 
```go
func main() {
    defer func() {
        if r := recover(); r != nil {
        fmt.Println("Поймали панику:", r)
        }
    }()
panic("что-то сломалось")
fmt.Println("Это не выполнится")
}
```

### 6. Как создать собственную ошибку через errors.New или fmt.Errorf?
`err := errors.New("something went wrong")` - сообщение об ошибке
`err := fmt.Errorf("user %d not found", id)` - сообщение об ошибке с параметрами
`err := fmt.Errorf("read failed: %w", originalErr)` - сообщение об ошибке с оберткой

### 7. Безопасно ли вернуть указатель на локальную переменную — почему?
Да, безопасно. Если функция возвращает указатель, то Go видит это и перенесет данную переменную в кучу

### 8. Для чего errors.Is и errors.As, приведите короткий пример.
error.Is проверяет наличие конкретной ошибки:
   проверка на наличие файла `if errors.Is(err, os.ErrNotExist)`
error.As проверяет наличие ошибки конкретного типа
   обнаруживаем ошибку определенного типа и выводим поля структуры

### 8. Как правильно округлить float64 до int, избегая переполнения?
Чтобы округлить `x float64` до `int` необходимо использовать `i := matn.Round(x)`. Для того чтобы избежать переполнения
следует проверить границы с помощью проверки `if x > math.MaxInt64`

### 9. Почему file.Close() обычно сразу помещают в defer после os.Open()?
Для гарантированного закрытия файла при любых условиях (panic или return в середине цикла)

### 10. Что произойдёт, если в программе случится panic, а recover не вызовется?
Программа прекратит свое дальнейшее выполнение