# Ревью по модулям 4-5

## Модуль 4
### 1. Из каких трёх компонентов состоит срез в Go и что каждый означает?
Срез - это структура из трех полей: pointer, len, cap. 
* pointer - указатель на базовый массив
* len - длина среза, количество инициализированных элементов
* cap - емкость, максимальное количество элементов

### 2. Как работает увеличение ёмкости среза при использовании функции append?
Если после `append` len = cap то емкость среза автоматически увеличивается в 2, если cap < 1024 
при cap >= 1024 количестве данных емкость среза увеличивается примерно на 25% (cap + cap/4)

### 3. Чем отличается длина среза от его ёмкости? Покажите на примере.
Длина среза - это количество элементов, которые уже существуют в срезе
Емкость - это максимальное количество элементов, которе мы можем положить в срез
Например: срез [1, 2, 3, 4, 5] с емкостью 10. На данный момент длина среза = 5 т.к. в срезе лежит всего 5 элементов, 
и мы можем добавить еще 5 элементов без увеличения емкости среза т.к. емкость позволяет хранить в срезе до 10
элементов включительно

### 4. Как создать независимую копию среза? Приведите два способа.
Чтобы создать независимую копию среза можно:
1. создать новый срез и с помощью цикла добавить все элементы из оригинального среза в новый срез
2. создать новый срез и использовать функцию `copy` 

### 5. Какая разница между nil-срезом и пустым срезом? Как их отличить?
nil - срез -> len = 0, cap = 0, базового массива нет
пустой срез  -> len = 0, cap >= 0, базовый массив есть
при сравнении с nil пустой срез вернет `false`, nil-срез вернут `true` 

### 6. Что происходит при обращении к несуществующему ключу в карте? Как это правильно проверить?
При обращении к несуществующему ключу в карте вернется `zero value` типа значения. Для проверки необходимо использовать
v, ok := map[k]     

### 7. Зачем нужна функция make при создании карты? Приведите пример.
При создании карты с помощью функции `make` карта автоматически инициализируется. Так же есть возможность
указать емкость для хеш-таблицы

### 8. Как заранее задать ёмкость карты? Какие это даёт преимущества?
С помощью функции `make` можно заранее указать емкость карты. Это позволяет минимизировать затраты памяти:
* меньше аллокаций
* меньше ресайзов
* лучше производительность
* меньше нагрузки на GC

### 9. Как удалить элемент из карты? Чем это отличается от установки значения в ноль?
Удалить элемент из карты можно с помощью функции `delete`. Если изменить значние в ноль, то при проверке наличия
ключа в карте вернутся true

### 10. Что такое вложенные структуры в Go и как использовать embedding?
Вложенные структуры - это структуры, которые содержат внутри себя одну или несколько других структур.
Пример: 
* есть структура Address с полями Country, City, Street, Building (хранит детализированную информацию об адресе)
* есть структура Person с полями Sex, Name, Age, Address (хранит некоторые персональные данные и адрес типа Address)
* можем обратиться к полям Address с помощью Person.Address.City 

### 11. Почему карты в Go не являются потокобезопасными?
Одновременная запись из горутин невозможна, будет паника
При записи может произойти эвакуация данных т.е. хеш-таблица может перемещать данные в другие ячейки или создавать 
бакеты. Если два потока делают это одновременно → структура повреждается.

### 12. Как карта в Go работает с коллизиями хешей?
Коллизии - это когда разные ключи дают одинаковый хеш.
1. БАКЕТЫ
В Go используется система бакетов:
* карта состоит из набора бакетов
* каждый бакет хранит до 8 пар ключ-значение
* если элементов больше - используется дополнительный бакет (overflow)

2. Кака hashmap реализована в Go?
* передаем ключ в хеш-функцию и получаем uint64
* вычисляем маску для наших бакетов (n-1, n - количество бакетов)
* вычисляем номер бакета, в который запишем значение (побитовое "и" hash & mask)
* переходим по индексу и перебором проверяем массив на наличие ключа. Если ключ найден -> перезаписываем значение,
если нет -> добавляем в первое свободное место 

3. КОЛЛИЗИЯ
При коллизиях, если ключи разные, то Go просто добавит элемент в первый пустой слот, иначе перезапишет значение.
Если в бакете уже 8 элементов и произошло переполнение, то создается overflow бакет, который связывается с основным 
бакетом и поиск продолжается в overflow бакете (получается цепочка бакетов, родительский бакет хранит указатель 
на overflow бакет)

### 13. Каким образом происходит рост карты в Go при добавлении элементов?
Resize происходит, когда число элементов превышает load factor карты (≈ 6.5 элементов на один бакет).
При ресайзе
* количество бакетов удваивается
* создается новый массив бакетов
* элементы перераспределяются в новые бакеты по их хешу (инкрементально т.е. переносятся постепенно при
последующих операциях)

### 14. Почему ключи карты должны быть сравниваемыми (comparable)?
При добавлении, поиска или удалении элемента карта реализует это по ключу => мапа должна понимать тот это ключ или нет.
Сделать она это может только сравнив для ключа



